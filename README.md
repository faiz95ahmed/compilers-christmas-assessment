# compilers-christmas-assessment

1 Specification
The programming language Algol 60 included only one looping construct, the for loop, but this could take different forms. A for loop had a ‘controlled variable’ that would be assigned a sequence of values as the loop body was executed. These values could be listed explicitly, as in

		for k := 1, 2, 3, 5 do print(k)
  
It was also possible to specify an arithmetic progression, as in this example:

		for k := 10 step 10 until 100 do print(k)

Here k takes the values 10, 20, 30, . . . , 100 in successive executions of the loop body. A third form of loop allowed more that just arithmetic progressions. Here is an example:

		k := 1;
		for k := 2 ∗ k while k < 1000 do print(k)
  
This prints 2, 4, 8, . . . , 512, stopping there because the next value, 1024, does not satisfy the test. These three forms – simple expressions, step-until elements, and while elements – could be combined, like this:

  for k := 1, 2, 3, 5, 10 step 10 until 100, 2 ∗ k while k < 1000 do
  print(k)
  
Perhaps unexpectedly, this program prints 1, 2, 3, 5, 10, 20, 30, . . . , 100, 220, 440, 880. The next value after 100 is 220, because (as the formal definition below makes explicit), k is set to 110 before the test k ≤ 100 fails, and the while element begins by computing 2 ∗ k with this value of k. As a more meaningful example, the following program computes a = floor(sqrt(b)) using binary search. A single loop encompasses two phases, one where d is growing until (a + d)^2 > x, and another where d is shrinking again.

  a := 0;
  for d := 1, 2 ∗ d while square(a + d) ≤ x, d div 2 while d ≥ 1 do
  if square(a + d) ≤ x then a := a + d

The meaning of for loops is defined in the following edited extract from the Revised Report on Algol 60 (note 1, note 2)

Description of the reference language
4. Statements
4.6. For Statements
4.6.1. Syntax [edited]
  <for list element> ::= 
  <arithmetic expression> |
  <arithmetic expression> step <arithmetic expression>
  until <arithmetic expression> |
  <arithmetic expression> while <Boolean expression>
  <for list> ::= <for list element> |
  <for list>, <for list element>
  <for clause> ::= for <variable> := <for list> do
  <for statement> ::= <for clause> <statement>
 
4.6.2 Examples (note 3)

  for q := 1 step s until n do A[q] := B[q]
  for k := 1, k × 2 while k < B do
  for j := I + G, L, 1 step 1 until N, C + D do
  A[k, j] := B[k, j]
  
4.6.3 Semantics
A for clause causes the statement S which it precedes to be repeatedly executed zero or more times. In addition it performs a sequence of assignments to its controlled variable. The process may be visualized by means of the following picture:
             ↓--------------------↑
Initialize; test; statement S; advance; successor
              ↓___________________________↑
                  for list exhausted
                  
In this picture the word initialize means: perform the first assignment of the for clause. Advance means: perform the next assignment of the for clause. Test determines if the last assignment has been done. If so, the execution continues with the successor of the for statement. If not, the statement following the for clause is executed.

4.6.4. The for list elements
The for list gives a rule for obtaining the values which are consecutively assigned to the controlled variable. This sequence of values is obtained from the for list elements by taking these one by one in the order in which they are written. The sequence of values generated by each of the three species of for list elements and corresponding execution of the statement S are given by the following rules:

4.6.4.1. Arithmetic expression. This element gives rise to one value, namely the value of the given arithmetic expression as calculated immediately before the corresponding execution of the statement S.

4.6.4.2. Step-until-element. An element of the form A step B until C, where A, B, and C are arithmetic expressions, gives rise to an execution which may be described most concisely in terms of additional Algol statements as follows [edited]:

    V := A;
  L1:
    if B > 0 then begin if V > C then go to Element exhausted end
    else begin if V < C then go to Element exhausted end;
    statement S;
    V := V + B;
    go to L1;
  
where V is the controlled variable of the for clause and Element exhausted points to the evaluation according to the next element of the for list, or if the step-until-element is the last of the list, to the next statement in the program.

4.6.4.3. While-element. The execution governed by a for list element of the form E while F, where E is an arithmetic and F a Boolean expression, is most concisely described in terms of additional Algol statements as follows:

  L3:
    V := E;
    if ¬F then go to Element exhausted;
    Statement S;
    go to L3;
    
where the notation is the same as in 4.6.4.2 above.

4.6.5. The value of the controlled variable upon exit
[Upon exit from a for statement owing] to the exhaustion of the for list, . . . the value of the controlled variable is undefined (note 5) after the exit.
The goal of this assignment is to produce a modern implementation of this looping construct by replacing the existing for loop in the compiler we used in Lab 4. To fit in with the rest of the language implemented by that compiler, you should implement Algol 60-style for loops with the following differences:

  • In accord with the syntactic style of the rest of the language, a <for clause> should govern a sequence of statements terminated by end; in Algol 60, a similar effect would be obtained by enclosing the sequence of statements in begin . . . end brackets.
  • A number of compiler test cases contain for loops with the existing syntax. To allow these to continue to pass, you should allow lo to hi as an abbreviation for lo step 1 until hi.
  • In Algol 60, for loops may have controlled variables with either real or integer type. Since real variables and arithmetic are not supported by the compiler in Lab 4, you should allow only integer variables and expressions.


1 Naur, P. (Ed.), Revised report on the algorithmic language Algol 60, Computer Journal, 5 (4), January 1963, pp. 349–67. Copies of this report and the paper by Knuth are linked from the course web page.
2 The extract has been edited to remove references to go to statements and labels and an unhelpful reference to the function sign.
3 The second example incorporates a correction proposed in Knuth, D. E., The remaining trouble spots in Algol 60, Comm. ACM, 10 (10), October 1967, pp. 611–18.
4 “Whenever . . . the outcome of a certain process is left undefined or said to be undefined, this is to be interpreted in the sense that a program only fully defines a computational process if the accompanying information specifies . . . the course of action to be taken in all such cases as may occur during the execution of the computation.” (Naur, op. cit., footnote on p. 352.)
